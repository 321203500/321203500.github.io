<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux文件操作命令</title>
      <link href="/2019/01/03/linux-wen-jian-cao-zuo-ming-ling/"/>
      <url>/2019/01/03/linux-wen-jian-cao-zuo-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>Linux文件操作命令：</p><ul><li>pwd - print working directory</li><li>cd - change directory</li><li>ls - list directory contents<br> -a - all<br>  -l - long<br>  -R - recursive</li><li>mkdir - make directory</li><li>rmdir - remove empty directory</li><li>touch</li><li>cp - copy</li><li>rm - remove</li><li>mv - move</li><li>less / more / head / tail</li><li>cat - concatenate</li><li>uniq / sort / cut / wc / diff</li><li><p>find / grep</p></li><li><p>ps -ef / ps -aux</p></li><li>netstat -nap</li><li>ifconfig / ip</li><li>top / sar</li><li>scp / sftp / ssh</li></ul><p>Linux安装软件和配置服务：</p><ol><li>包管理工具 - yum / rpm / apt / deb</li><li>源代码构建安装<ul><li>wget</li><li>gunzip / xz -d</li><li>tar -xvf</li><li>make &amp;&amp; make install</li><li>ln -s 源 目标</li></ul></li></ol><p>systemctl </p><pre><code>- start / stop / restart / status / enable / disable</code></pre><p>service</p><p>firewalld / iptables - 防火墙</p><p>使用vim</p><p>命令模式 –i/a–&gt; 插入模式（编辑模式） –Esc–&gt; 命令模式<br>命令模式 –:?/–&gt; 末行模式 –Enter–&gt; 命令模式</p><p>Ctrl+e / Ctrl+y - 滚动一行<br>Ctrl+f / Ctrl+b - 滚动一页<br>gg - 到首行<br>G - 到末行<br>100G - 到100行<br>hjkl - 左下上右移动光标<br>$ - 光标到行尾<br>0 - 光标到行首<br>dd / dw / d0 / d$ - 删除<br>yy / p - 复制 / 黏贴<br>u / Ctrl+r - 撤销 / 恢复<br>ZZ / :wq - 保存退出 - ! - 强制操作</p><p>/搜索内容（正则） - 查找 - n / N - 向下/上搜索<br>?搜索内容（正则） - 查找<br>:1,$s/搜索的内容（正则）/替换后的内容/ice - 查找替换</p><p>版本比较 - vim -d 文件1 文件2<br>多文件查看 - vim 文件1 文件2 文件3<br>:ls - 查看文件<br>:b - 切换文件<br>:sp / :vs - 拆分窗口<br>Ctrl+w Ctrl+w - 切换窗口</p><p>配置vim —&gt; ~/.vimrc<br>set nu<br>set ts=4<br>set expandtab<br>set autoindent<br>set nohls<br>syntax on<br>set ruler </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx服务器安装</title>
      <link href="/2019/01/03/nginx-fu-wu-qi-an-zhuang/"/>
      <url>/2019/01/03/nginx-fu-wu-qi-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx服务器"><a href="#Nginx服务器" class="headerlink" title="Nginx服务器"></a>Nginx服务器</h1><h3 id="1-阿里云添加80端口"><a href="#1-阿里云添加80端口" class="headerlink" title="1.阿里云添加80端口"></a>1.阿里云添加80端口</h3><p>阿里云上默认只有一个22端口用来做远程登录，如果希望在阿里云上安装支持http请求的nginx服务器，需要给阿里云添加80端口</p><p><img src="./img/aliyun0.png" alt="打开安全组设置"><br><img src="./img/aliyun2.png" alt=""><br><img src="./img/aliyun3.png" alt=""><br><img src="./img/aliyun4.png" alt=""></p><h3 id="2-安装nginx"><a href="#2-安装nginx" class="headerlink" title="2. 安装nginx"></a>2. 安装nginx</h3><p>a) 添加nginx存储库  </p><pre class=" language-python"><code class="language-python">    yum install epel<span class="token operator">-</span>release</code></pre><p>b) 安装nginx</p><pre class=" language-python"><code class="language-python">    yum install nginx</code></pre><p>c) 运行nginx<br>Nginx不会自行启动。要运行Nginx  </p><pre><code>    systemctl start nginx</code></pre><p>nginx的运行命令:  </p><pre><code>    systemctl status nginx 查看nginx的状态      systemctl start/stop/enable/disable nginx 启动/关闭/设置开机启动/禁止开机启动  </code></pre><p>d) 系统启动时启动Nginx  </p><pre><code>    systemctl enable nginx</code></pre><p>e）如果您正在运行防火墙，请运行以下命令以允许HTTP和HTTPS通信：   </p><pre><code>    sudo firewall-cmd --permanent --zone=public --add-service=http     sudo firewall-cmd --permanent --zone=public --add-service=https    sudo firewall-cmd --reload</code></pre><h3 id="3-nginx目录共享配置"><a href="#3-nginx目录共享配置" class="headerlink" title="3.nginx目录共享配置"></a>3.nginx目录共享配置</h3><p>a) 在contOS目录中确定一个需要共享的文件夹，例如： /home/yuting<br>b) 打开 etc/nginx/nginx.conf 文件，设置server</p><pre><code>    #共享设置 - 在浏览器中输入服务器ip地址，会展示共享目录的文件列表    root /home/yuting;    location / {           autoindex on;           autoindex_exact_size on;           autoindex_localtime on;    }  </code></pre><p>除了可以共享文件，还可以自定义页面</p><pre><code>    #自定义服务器页面    location / {            root /home/yuting;            index index.html index.htm;    }</code></pre><p>注意： 如果出现权限问题，可以修改目录的权限  </p><h1 id="ssh密钥认证"><a href="#ssh密钥认证" class="headerlink" title="ssh密钥认证"></a>ssh密钥认证</h1><p>1.在主机和从机上执行：<code>ssh-keygen</code></p><p>2.在从机上执行:  <code>scp  id_rsa.pub  root@主机地址:~/.ssh/master.pub</code><br>(上面这条指令是将从机上的 id_rsa.pub文件拷贝传递给到主机的.ssh文件夹下，并且命名为’master.pub’)</p><p>3.在主机中的.ssh文件夹中创建authorized_keys文件： <code>touch authorized_keys</code> </p><p>4.修改文件authorized_keys的权限: <code>chmod 600  authorized_keys</code>  </p><p>5.将master.pub放进authorized_keys文件中:  <code>cat master.pub &gt;&gt;  authorized_keys</code></p><p>6.在操作主机的时候，需要主机能够自己免密访问自己就将自己的公钥放在自己的authorized_keys文件中</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis指令(总结)</title>
      <link href="/2019/01/03/redis-zhi-ling-zong-jie/"/>
      <url>/2019/01/03/redis-zhi-ling-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>登录指令：</p><p>redis-server –requirepass 123456 –appendonly yes –port 6379</p><p>Linux + Apache + MySQL + PHP</p><p>KV存储系统 - REmote DIctionary Server</p><p>Github - 20000 - 50000+</p><p>Github、Twitter、YouTube</p><p>提供高速缓存服务 - 缓存热点数据（访问量大数据量不大）<br>缓解了数据的压力（高频访问数据不用直接访问数据库）</p><p>Redis提供了两种持久化数据的方案：</p><ol><li>RDB - 默认开启</li><li>AOF - 默认关闭 –appendonly yes</li></ol><p>auth - 验证身份<br>ping - 心跳事件<br>set - 设置键值对<br>get - 取值<br>expire - 设置超时时间<br>ttl - 查看剩余时间<br>del - 删除键<br>keys - 查看键<br>exists - 判断键是否存在</p><p>flushdb - 清空数据库中的键值对<br>flushall - 清除所有数据库中的所有键值对<br>select - 切换底层数据库<br>dbsize - 查看当前数据库有多少组键值对</p><p>save / bgsave - 保存数据/后台保存数据<br>shutdown - 关闭服务器<br>quit - 退出</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql查语法</title>
      <link href="/2019/01/03/mysql-cha-yu-fa/"/>
      <url>/2019/01/03/mysql-cha-yu-fa/</url>
      
        <content type="html"><![CDATA[<p>– 创建人力资源管理系统数据库<br>drop database if exists hrs;<br>create database hrs default charset utf8;<br>– 切换数据库上下文环境<br>use hrs;<br>– 删除表<br>drop table if exists tb_emp;<br>drop table if exists tb_dept;<br>– 创建部门表<br>create table tb_dept<br>(<br>dno int comment ‘部门编号’,<br>dname varchar(10) not null comment ‘部门名称’,<br>dloc varchar(20) not null    comment ‘部门所在地’,<br>primary key (dno)<br>);<br>– 添加部门记录<br>insert into tb_dept values<br> (10, ‘会计部’, ‘北京’),<br> (20, ‘研发部’, ‘成都’),<br> (30, ‘销售部’, ‘重庆’),<br> (40, ‘运维部’, ‘深圳’);<br>– 创建员工表<br>create table tb_emp<br>(<br>eno int comment ‘员工编号’,<br>ename varchar(20) not null comment ‘员工姓名’,<br>job varchar(20) not null comment ‘员工职位’,<br>mgr int comment ‘主管编号’,<br>sal int not null comment ‘员工工资’,<br>comm int comment ‘每月补贴’,<br>dno int comment ‘所在部门编号’,<br>primary key (eno),<br>foreign key (dno) references tb_dept (dno)<br>);</p><p>– 添加员工记录<br>insert into tb_emp values<br> (7800, ‘张三丰’, ‘总裁’, null, 9000, 1200, 20),<br> (2056, ‘乔峰’, ‘分析师’, 7800, 5000, 1500, 20),<br> (3088, ‘李莫愁’, ‘设计师’, 2056, 3500, 800, 20),<br> (3211, ‘张无忌’, ‘程序员’, 2056, 3200, null, 20),<br> (3233, ‘丘处机’, ‘程序员’, 2056, 3400, null, 20),<br> (3251, ‘张翠山’, ‘程序员’, 2056, 4000, null, 20),<br> (5566, ‘宋远桥’, ‘会计师’, 7800, 4000, 1000, 10),<br> (5234, ‘郭靖’, ‘出纳’, 5566, 2000, null, 10),<br> (3344, ‘黄蓉’, ‘销售主管’, 7800, 3000, 800, 30),<br> (1359, ‘胡一刀’, ‘销售员’, 3344, 1800, 200, 30),<br> (4466, ‘苗人凤’, ‘销售员’, 3344, 2500, null, 30),<br> (3244, ‘欧阳锋’, ‘程序员’, 3088, 3200, null, 20),<br> (3577, ‘杨过’, ‘会计’, 5566, 2200, null, 10),<br> (3588, ‘朱九真’, ‘会计’, 5566, 2500, null, 10);</p><p>– 查询薪资最高的员工姓名和工资<br>select ename as 姓名, sal as 月薪 from tb_emp<br>where sal=(select max(sal) from tb_emp);</p><p>– 查询员工的姓名和年薪((工资+补贴)<em>12)<br>select ename as 姓名, (sal+ifnull(comm,0))</em>12 as 年薪<br>from tb_emp order by 年薪 desc;</p><p>– 查询有员工的部门的编号和人数<br>select dno as 部门编号, count(dno) as 人数<br>from tb_emp group by dno;</p><p>– 查询所有部门的名称和人数<br>– 当列有二义性的时候使用完全限定名<br>select dname as 部门名称, total from tb_dept t1,<br>(select dno, count(dno) as total from tb_emp group by dno) t2<br>where t1.dno=t2.dno;</p><p>select dname as 部门名称, ifnull(total,0) from tb_dept t1 left outer join<br>(select dno, count(dno) as total from tb_emp group by dno) t2<br>on t1.dno=t2.dno;</p><p>– 查询薪资最高的员工(Boss除外)的姓名和工资<br>select ename as 姓名, sal as 薪资 from tb_emp<br>where sal=(select max(sal) from tb_emp where mgr);<br>– 查询薪水超过平均薪水的员工的姓名和工资<br>select ename as 姓名, sal as 薪资 from tb_emp<br>where sal&gt;(select avg(sal) from tb_emp);<br>– 查询薪水超过其所在部门平均薪水的员工的姓名、部门编号和工资<br>select ename, t1.dno, sal from tb_emp t1 inner join<br>(select dno, avg(sal) as avgsal from tb_emp group by dno) t2<br>on t1.dno=t2.dno<br>where sal&gt;avgsal;<br>– 查询部门中薪水最高的人姓名、工资和所在部门名称<br>select ename as 名字, sal as 工资, dname as 部门名称 from tb_dept t3 inner join<br>(select ename, sal, t1.dno from tb_emp t1 inner join<br>(select dno, max(sal) as maxsal from tb_emp group by dno) t2<br>on t1.dno=t2.dno<br>where sal=maxsal) t4<br>on t3.dno=t4.dno;<br>– 查询主管的姓名和职位</p><p>– 集合运算和去重操作性能都非常糟糕应该尽量避免使用<br>– 可以使用exists和not exists来替代集合运算和去重</p><p>select ename, job from tb_emp t1 where exists<br>(select ‘x’ from tb_emp t2 where t1.eno=t2.mgr);</p><p>select ename, job from tb_emp t1 where not exists<br>(select ‘x’ from tb_emp t2 where t1.eno=t2.mgr);<br>– 查询薪资排名4~6名的员工姓名和工资<br>select ename, sal from tb_emp order by sal desc limit 3,3;<br>select ename, sal from tb_emp order by sal desc limit 3 offset 3;</p><p>– select - from - where - group by(分组) - having - order by(排序) - limit</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis命令</title>
      <link href="/2019/01/03/redis-ming-ling/"/>
      <url>/2019/01/03/redis-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>1、连接操作相关的命令</p><p>quit：关闭连接（connection）</p><p>auth：简单密码认证</p><p>2、对value操作的命令</p><p>exists(key)：确认一个key是否存在</p><p>del(key)：删除一个key</p><p>type(key)：返回值的类型</p><p>keys(pattern)：返回满足给定pattern的所有key</p><p>randomkey：随机返回key空间的一个key</p><p>rename(oldname, newname)：将key由oldname重命名为newname，若newname存在则删除newname表示的key</p><p>dbsize：返回当前数据库中key的数目</p><p>expire：设定一个key的活动时间（s）</p><p>ttl：获得一个key的活动时间</p><p>select(index)：按索引查询</p><p>move(key, dbindex)：将当前数据库中的key转移到有dbindex索引的数据库</p><p>flushdb：删除当前选择数据库中的所有key</p><p>flushall：删除所有数据库中的所有key</p><p>3、对String操作的命令</p><p>set(key, value)：给数据库中名称为key的string赋予值value</p><p>get(key)：返回数据库中名称为key的string的value</p><p>getset(key, value)：给名称为key的string赋予上一次的value</p><p>mget(key1, key2,…, key N)：返回库中多个string（它们的名称为key1，key2…）的value</p><p>setnx(key, value)：如果不存在名称为key的string，则向库中添加string，名称为key，值为value</p><p>setex(key, time, value)：向库中添加string（名称为key，值为value）同时，设定过期时间time</p><p>mset(key1, value1, key2, value2,…key N, value N)：同时给多个string赋值，名称为key i的string赋值value i</p><p>msetnx(key1, value1, key2, value2,…key N, value N)：如果所有名称为key i的string都不存在，则向库中添加string，</p><p>名称key i赋值为value i</p><p>incr(key)：名称为key的string增1操作</p><p>incrby(key, integer)：名称为key的string增加integer</p><p>decr(key)：名称为key的string减1操作</p><p>decrby(key, integer)：名称为key的string减少integer</p><p>append(key, value)：名称为key的string的值附加value</p><p>substr(key, start, end)：返回名称为key的string的value的子串</p><p>4、对List操作的命令</p><p>rpush(key, value)：在名称为key的list尾添加一个值为value的元素</p><p>lpush(key, value)：在名称为key的list头添加一个值为value的 元素</p><p>llen(key)：返回名称为key的list的长度</p><p>lrange(key, start, end)：返回名称为key的list中start至end之间的元素（下标从0开始，下同）</p><p>ltrim(key, start, end)：截取名称为key的list，保留start至end之间的元素</p><p>lindex(key, index)：返回名称为key的list中index位置的元素</p><p>lset(key, index, value)：给名称为key的list中index位置的元素赋值为value</p><p>lrem(key, count, value)：删除count个名称为key的list中值为value的元素。</p><p>count为0，删除所有值为value的元素，count&gt;0从头至尾删除count个值为value的元素，count&lt;0从尾到头删除|count|个值为value的元素。 </p><p>lpop(key)：返回并删除名称为key的list中的首元素 rpop(key)：返回并删除名称为key的list中的尾元素 </p><p>blpop(key1, key2,… key N, timeout)：lpop命令的block版本。</p><p>即当timeout为0时，若遇到名称为key i的list不存在或该list为空，则命令结束。</p><p>如果timeout&gt;0，则遇到上述情况时，等待timeout秒，如果问题没有解决，则对keyi+1开始的list执行pop操作。</p><p>brpop(key1, key2,… key N, timeout)：rpop的block版本。参考上一命令。</p><p>rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部</p><p>5、对Set操作的命令</p><p>sadd(key, member)：向名称为key的set中添加元素member</p><p>srem(key, member) ：删除名称为key的set中的元素member</p><p>spop(key) ：随机返回并删除名称为key的set中一个元素</p><p>smove(srckey, dstkey, member) ：将member元素从名称为srckey的集合移到名称为dstkey的集合</p><p>scard(key) ：返回名称为key的set的基数</p><p>sismember(key, member) ：测试member是否是名称为key的set的元素</p><p>sinter(key1, key2,…key N) ：求交集</p><p>sinterstore(dstkey, key1, key2,…key N) ：求交集并将交集保存到dstkey的集合</p><p>sunion(key1, key2,…key N) ：求并集</p><p>sunionstore(dstkey, key1, key2,…key N) ：求并集并将并集保存到dstkey的集合</p><p>sdiff(key1, key2,…key N) ：求差集</p><p>sdiffstore(dstkey, key1, key2,…key N) ：求差集并将差集保存到dstkey的集合</p><p>smembers(key) ：返回名称为key的set的所有元素</p><p>srandmember(key) ：随机返回名称为key的set的一个元素</p><p>6、对zset（sorted set）操作的命令</p><p>zadd(key, score, member)：向名称为key的zset中添加元素member，score用于排序。如果该元素已经存在，则根据score更新该元素的顺序。</p><p>zrem(key, member) ：删除名称为key的zset中的元素member</p><p>zincrby(key, increment, member) ：如果在名称为key的zset中已经存在元素member，则该元素的score增加increment；</p><p>否则向集合中添加该元素，其score的值为increment</p><p>zrank(key, member) ：返回名称为key的zset（元素已按score从小到大排序）中member元素的rank（即index，从0开始），</p><p>若没有member元素，返回“nil”</p><p>zrevrank(key, member) ：返回名称为key的zset（元素已按score从大到小排序）中member元素的rank（即index，从0开始），</p><p>若没有member元素，返回“nil”</p><p>zrange(key, start, end)：返回名称为key的zset（元素已按score从小到大排序）中的index从start到end的所有元素</p><p>zrevrange(key, start, end)：返回名称为key的zset（元素已按score从大到小排序）中的index从start到end的所有元素</p><p>zrangebyscore(key, min, max)：返回名称为key的zset中score &gt;= min且score &lt;= max的所有元素 </p><p>zcard(key)：返回名称为key的zset的基数 zscore(key, element)：返回名称为key的zset中元素element的</p><p>score zremrangebyrank(key, min, max)：删除名称为key的zset中rank &gt;= min且rank &lt;= max的所有元素 </p><p>zremrangebyscore(key, min, max) ：删除名称为key的zset中score &gt;= min且score &lt;= max的所有元素</p><p>zunionstore / zinterstore(dstkeyN, key1,…,keyN, WEIGHTS w1,…wN, AGGREGATE SUM|MIN|MAX)：对N个zset求并集和交集，</p><p>并将最后的集合保存在dstkeyN中。对于集合中每一个元素的score，在进行AGGREGATE运算前，都要乘以对于的WEIGHT参数。</p><p>如果没有提供WEIGHT，默认为1。默认的AGGREGATE是SUM，即结果集合中元素的score是所有集合对应元素进行SUM运算的值，而MIN和MAX是指，</p><p>结果集合中元素的score是所有集合对应元素中最小值和最大值。</p><p>7、对Hash操作的命令</p><p>hset(key, field, value)：向名称为key的hash中添加元素field&lt;—&gt;value</p><p>hget(key, field)：返回名称为key的hash中field对应的value</p><p>hmget(key, field1, …,field N)：返回名称为key的hash中field i对应的value</p><p>hmset(key, field1, value1,…,field N, value N)：向名称为key的hash中添加元素field i&lt;—&gt;value i</p><p>hincrby(key, field, integer)：将名称为key的hash中field的value增加integer</p><p>hexists(key, field)：名称为key的hash中是否存在键为field的域</p><p>hdel(key, field)：删除名称为key的hash中键为field的域</p><p>hlen(key)：返回名称为key的hash中元素个数</p><p>hkeys(key)：返回名称为key的hash中所有键</p><p>hvals(key)：返回名称为key的hash中所有键对应的value</p><p>hgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value</p><p>8、持久化</p><p>save：将数据同步保存到磁盘</p><p>bgsave：将数据异步保存到磁盘</p><p>lastsave：返回上次成功将数据保存到磁盘的Unix时戳</p><p>shundown：将数据同步保存到磁盘，然后关闭服务</p><p>9、远程服务控制</p><p>info：提供服务器的信息和统计</p><p>monitor：实时转储收到的请求</p><p>slaveof：改变复制策略设置</p><p>config：在运行时配置Redis服务器</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="/2019/01/03/title/"/>
      <url>/2019/01/03/title/</url>
      
        <content type="html"><![CDATA[<h1 id="你好！"><a href="#你好！" class="headerlink" title="你好！"></a>你好！</h1><h1 id="hello！"><a href="#hello！" class="headerlink" title="hello！"></a>hello！</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vim编辑器之神</title>
      <link href="/2019/01/03/vim-bian-ji-qi-zhi-shen/"/>
      <url>/2019/01/03/vim-bian-ji-qi-zhi-shen/</url>
      
        <content type="html"><![CDATA[<h1 id="vim编辑器之神"><a href="#vim编辑器之神" class="headerlink" title="vim编辑器之神"></a>vim编辑器之神</h1><h3 id="配置vimrc配置"><a href="#配置vimrc配置" class="headerlink" title="配置vimrc配置"></a>配置vimrc配置</h3><p>在shell中可以通过 <code>vim ~/.vimrc</code> 或者 <code>vim /etc/vimrc</code> 打开vimrc文件对vim进行配置。在这个文件中可以进行很多和vim相关的配置，常用的如下（如果对其他配置感兴趣的可以自己百度）：</p><p><img src="./img/vim1.png" alt=""> </p><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="1-模式切换"><a href="#1-模式切换" class="headerlink" title="1.模式切换"></a>1.模式切换</h4><p>我们可以将vim分为命令模式、编辑模式和末行模式三种<br><strong>命令模式：</strong>进入vim的时候vim是处于命令模式状态下的，这个时候输入内容不会出现在编辑区  (最末什么都没有)</p><p><strong>末行模式：</strong>在命令模式下输入冒号，让vim进入末行模式。在末行模式的冒号后面可以输入相关的一些指令进行相关操作  (最后有一个冒号)</p><p><strong>编辑模式：</strong>在命令模式下按’i’进入编辑模式。在编辑模式下可以对文件内容进行编辑 (最后 –INSERT– 或者 –插入–)  </p><p>####2.保存和退出<br>在末行模式下输入相应的指令可以对编辑区的内容进行保存和退出vim界面<br><strong>w</strong> – 只保存(类似快捷键ctr+s)<br><strong>q</strong> – 退出（在编辑区的内容全部都保存的情况下才有效）<br><strong>wq</strong> – 保存并退出<br><strong>q!</strong>  – 强制退出（不保存修改信息）    </p><p>####3.光标操作<br>以下光标操作都是在命令模式下输入的<br><strong>^(shift+6)</strong>  – 移动到行首<br><strong>$(shift+4)</strong>  – 移动到行尾<br><strong>G(shift+g)</strong>    – 移动到文件末尾<br><strong>行号G</strong>            – 移动到指定行,例如:30G, 让光标直接跳转到行号是30的那一行<br><strong>gg</strong>                – 移动到文件开头  </p><p>####4.文本操作<br>以下操作不带冒号的是在命令模式下输入，前面有冒号代码后面的内容是在末行模式下输入<br><strong>dd</strong>            – 删除光标所在的行<br><strong>数字dd</strong>        – 从光标所在行开始往后面开始删，删除指定数量行内容<br><strong>:%d</strong>        – 删除所有     </p><p><strong>yy</strong>         – 复制光标所在的行<br><strong>数字yy</strong>        – 从光标所在行开始复制指定行数的内容<br><strong>p</strong>            – 将复制的内容粘贴到光标所在的位置<br><strong>u</strong>            – 撤销<br><strong>ctr+r</strong>    – 反撤销    </p><p><strong>:%!sort</strong>  – 对内容排序  </p><p><strong>:/查找对象[/gice]</strong>    – 搜索匹配正则表达式的内容，按回车回到命令模式后按n往前查找，按N往后查找  </p><p>*<em>:1,$s/被替换对象/替换内容[/gice</em>]*    – 将正则表达式匹配到的内容替换成指定内容   </p><pre><code>-    g: 全局匹配  -     i: 忽略大小写 -   c: 替换时需要提示  -   e: 忽略错误  </code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端(总结)</title>
      <link href="/2019/01/03/qian-duan-zong-jie/"/>
      <url>/2019/01/03/qian-duan-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>1.HTML标签 - 承载内容 - content<br>2.CSS - 渲染页面 - display </p><ul><li>选择器<ul><li>通配符</li><li>标签选择器</li><li>类选择器</li><li>id选择器</li><li>属性选择器</li><li>后代选择器 / 父子选择器</li><li>兄弟选择器 / 相邻兄弟选择器</li></ul></li><li>就近原则/具体性原则/重要性原则</li><li>盒子模型（内容-padding-border-背景图-背景色-margin）</li><li>常用样式属性和常用属性值</li><li>伪类 / 伪元素</li></ul><p>3.JavaScript - 交互行为 - behavior</p><ul><li>语法规范 - ECMAScript</li><li>BOM - 浏览器对象模型 - window</li><li>DOM - 文档对象类型 - document<ul><li>getElementById() / getElementsByTagName() /<br>getElementsByClassName() / querySelector() /<br>querySelectorAll()</li><li>createElement() / appendChild() / insertBefore()</li><li>removeChild()</li><li>innerHTML / textContent / className / style</li><li>parentNode / children / prevSibling / nextSibling</li><li>addEventListener / removeEventListener</li></ul></li><li>jQuery - window.$ / window.jQuery<ul><li>$(‘样式表选择器’)：获取页面元素返回jQuery对象</li><li>$(‘&lt;标签&gt;’)：创建新元素得到jQuery对象</li><li>$(原生JavaScript对象)：将原生JS对象转换成jQuery对象</li><li>$(function(){}):绑定页面加载完成之后要执行的回调函数</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git常用指令</title>
      <link href="/2019/01/02/git-chang-yong-zhi-ling/"/>
      <url>/2019/01/02/git-chang-yong-zhi-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="git常用指令"><a href="#git常用指令" class="headerlink" title="git常用指令"></a>git常用指令</h1><h2 id="1-基本指令"><a href="#1-基本指令" class="headerlink" title="1.基本指令"></a>1.基本指令</h2><p><code>git init</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ——  新建git仓库<br><code>git add 文件/文件夹</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ——  将文件添加到缓存区中<br><code>git add -A</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; — 添加所有内容到缓存区中<br><code>git stutas</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;———    查看git状态<br><code>git commit -m  ‘提交信息’</code>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——  将缓存区中的内容全部提交到git本地仓库中  </p><p><code>git log</code>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——-    查看提交日志  </p><p><code>git reset  - - hard   HEAD</code>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——   让工作目录中的内容和仓库中的内容保持一致<br><code>git reset  --hard HEAD^</code>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——  回到上一个版本<br><code>git  reset  - - hard 版本号</code>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——  回到指定的版本<br><code>git checkout  - -  文件名</code>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ——  从暂存区中恢复工作目录中的内容(让工作区中的指定文件，回到上次提交的时候的状态)  </p><p><code>git clone &lt;url&gt;</code> - 将服务器上的项目(仓库)克隆 (使用https地址需要输入密码，使用ssh地址需要添加公钥)  </p><p><code>git remote add origin 地址</code>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—– 关联远程仓库(只需要关联一次)</p><p><code>git push [-u] origin master</code>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—– 提交(-u在第一次提交分之的时候才用)  </p><h2 id="2-分之管理"><a href="#2-分之管理" class="headerlink" title="2.分之管理"></a>2.分之管理</h2><p>创建仓库会默认给我们创建一个master分之,这个分之一般作为提交和发布分之;开发一般会自己创建一个develop分之，用来开发和测试;多人协作的时候还可能根据不同的人或者(不同的功能)创建不同的分之，用来独立开发  </p><p>常见分之： master(主要是合并develop), develop(主要合并下面的其他分支), 功能/人员分之(开发)  </p><p><code>git branch [-a]</code>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        - 查看分之<br><code>git branch 分之名</code>        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 创建分之<br><code>git checkout   分支名</code>        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-   切换分之<br><code>git checkout -b 分之名</code>        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    - 切换并创建新的分之<br><code>git diff    分之1  分之2</code>        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 查看两个分之之间的差异<br><code>git merge 分之名</code>            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 让当前分之和指定分之进行合并     </p><p>注意: 切换分之、push、pull，这些操作前要保证工作区是clean  </p><p>怎么避免冲突：  不要发生多个分之对同一个文件在同一个版本下进行修改(和同伴确认和商量)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/12/21/hello-world/"/>
      <url>/2018/12/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
